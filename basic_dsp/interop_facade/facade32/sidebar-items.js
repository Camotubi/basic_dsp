initSidebarItems({"fn":[["abs32",""],["abs_ops1_f32",""],["abs_ops2_f32",""],["acos32",""],["acos_ops1_f32",""],["acos_ops2_f32",""],["acosh32",""],["acosh_ops1_f32",""],["acosh_ops2_f32",""],["add_complex_ops1_f32",""],["add_complex_ops2_f32",""],["add_points_ops1_f32",""],["add_points_ops2_f32",""],["add_real_ops1_f32",""],["add_real_ops2_f32",""],["add_smaller_vector32",""],["add_vector32",""],["add_vector_ops1_f32",""],["add_vector_ops2_f32",""],["apply_custom_window32","Creates a window from the function `window` and the void pointer `window_data`. The `window_data` pointer is passed to the `window` function at every call and can be used to store parameters."],["apply_window32","`window` argument is translated to:"],["asin32",""],["asin_ops1_f32",""],["asin_ops2_f32",""],["asinh32",""],["asinh_ops1_f32",""],["asinh_ops2_f32",""],["atan32",""],["atan_ops1_f32",""],["atan_ops2_f32",""],["atanh32",""],["atanh_ops1_f32",""],["atanh_ops2_f32",""],["clone32",""],["clone_from_ops1_f32",""],["clone_from_ops2_f32",""],["complex_conj_ops1_f32",""],["complex_conj_ops2_f32",""],["complex_data32",""],["complex_divide32",""],["complex_dot_product32",""],["complex_offset32",""],["complex_scale32",""],["complex_statistics32",""],["complex_statistics_splitted32",""],["conj32",""],["convolve32","`impulse_response` argument is translated to:"],["convolve_complex32","Convolves the vector with an impulse response defined by `impulse_response` and the void pointer `impulse_response_data`. The `impulse_response_data` pointer is passed to the `impulse_response` function at every call and can be used to store parameters."],["convolve_real32","Convolves the vector with an impulse response defined by `impulse_response` and the void pointer `impulse_response_data`. The `impulse_response_data` pointer is passed to the `impulse_response` function at every call and can be used to store parameters."],["convolve_vector32",""],["correlate32",""],["cos32",""],["cos_ops1_f32",""],["cos_ops2_f32",""],["cosh32",""],["cosh_ops1_f32",""],["cosh_ops2_f32",""],["cum_sum32",""],["decimatei32",""],["delete_vector32",""],["diff32",""],["diff_with_start32",""],["div_points_ops1_f32",""],["div_points_ops2_f32",""],["div_vector_ops1_f32",""],["div_vector_ops2_f32",""],["divide_smaller_vector32",""],["divide_vector32",""],["exec_prepared_ops1_f32",""],["exec_prepared_ops2_f32",""],["exp32",""],["exp_ops1_f32",""],["exp_ops2_f32",""],["expf32",""],["expf_ops1_f32",""],["expf_ops2_f32",""],["extend_prepared_ops1_f32","Prepares an operation. multi_ops1 will not be made available in for interop since the same functionality  can be created with prepared ops, and internally this is what this lib does too."],["fft32",""],["fft_shift32",""],["get_allocated_len32",""],["get_delta32",""],["get_domain32","Returns the vector domain as integer:"],["get_imag32",""],["get_len32",""],["get_mag_phase32",""],["get_magnitude32",""],["get_phase32",""],["get_points32",""],["get_real32",""],["get_real_imag32",""],["get_value32",""],["ifft32",""],["ifft_shift32",""],["interpolate_hermite32",""],["interpolate_lin32",""],["interpolatef32","`impulse_response` argument is translated to:"],["interpolatef_custom32","Convolves the vector with an impulse response defined by `impulse_response` and the void pointer `impulse_response_data`. The `impulse_response_data` pointer is passed to the `impulse_response` function at every call and can be used to store parameters."],["interpolatei32","`frequency_response` argument is translated to:"],["interpolatei_custom32","Convolves the vector with an impulse response defined by `frequency_response` and the void pointer `frequency_response_data`. The `frequency_response_data` pointer is passed to the `frequency_response` function at every call and can be used to store parameters."],["is_complex32",""],["ln32",""],["ln_ops1_f32",""],["ln_ops2_f32",""],["log32",""],["log_ops1_f32",""],["log_ops2_f32",""],["magnitude32",""],["magnitude_ops1_f32",""],["magnitude_ops2_f32",""],["magnitude_squared32",""],["magnitude_squared_ops1_f32",""],["magnitude_squared_ops2_f32",""],["map_aggregate_complex32","Warning: This function interface heavily works around the Rust type system and the safety it provides. Use with great care!"],["map_aggregate_real32","Warning: This function interface heavily works around the Rust type system and the safety it provides. Use with great care!"],["map_complex_ops1_f32",""],["map_complex_ops2_f32",""],["map_inplace_complex32",""],["map_inplace_real32",""],["map_real_ops1_f32",""],["map_real_ops2_f32",""],["merge32",""],["mirror32",""],["mul_points_ops1_f32",""],["mul_points_ops2_f32",""],["mul_vector_ops1_f32",""],["mul_vector_ops2_f32",""],["multiply_complex_exponential32",""],["multiply_complex_exponential_ops1_f32",""],["multiply_complex_exponential_ops2_f32",""],["multiply_complex_ops1_f32",""],["multiply_complex_ops2_f32",""],["multiply_frequency_response32","`frequency_response` argument is translated to:"],["multiply_frequency_response_complex32","Convolves the vector with an impulse response defined by `frequency_response` and the void pointer `frequency_response_data`. The `frequency_response` pointer is passed to the `frequency_response` function at every call and can be used to store parameters."],["multiply_frequency_response_real32","Convolves the vector with an impulse response defined by `frequency_response` and the void pointer `frequency_response_data`. The `frequency_response_data` pointer is passed to the `frequency_response` function at every call and can be used to store parameters."],["multiply_real_ops1_f32",""],["multiply_real_ops2_f32",""],["multiply_smaller_vector32",""],["multiply_vector32",""],["new32",""],["new_with_performance_options32",""],["override_data32",""],["phase32",""],["phase_ops1_f32",""],["phase_ops2_f32",""],["plain_fft32",""],["plain_ifft32",""],["plain_sfft32",""],["plain_sifft32",""],["powf32",""],["powf_ops1_f32",""],["powf_ops2_f32",""],["prepare_argument32",""],["prepare_argument_padded32",""],["prepared_ops1_f32","Prepares an operation. multi_ops1 will not be made available in for interop since the same functionality  can be created with prepared ops, and internally this is what this lib does too."],["prepared_ops2_f32","Prepares an operation. multi_ops2 will not be made available in for interop since the same functionality  can be created with prepared ops, and internally this is what this lib does too."],["real_dot_product32",""],["real_offset32",""],["real_scale32",""],["real_statistics32",""],["real_statistics_splitted32",""],["reverse32",""],["root32",""],["root_ops1_f32",""],["root_ops2_f32",""],["set_len32",""],["set_mag_phase32",""],["set_real_imag32",""],["set_value32",""],["sfft32",""],["sifft32",""],["sin32",""],["sin_ops1_f32",""],["sin_ops2_f32",""],["sinh32",""],["sinh_ops1_f32",""],["sinh_ops2_f32",""],["split_into32",""],["sqrt32",""],["sqrt_ops1_f32",""],["sqrt_ops2_f32",""],["square32",""],["square_ops1_f32",""],["square_ops2_f32",""],["sub_points_ops1_f32",""],["sub_points_ops2_f32",""],["sub_vector_ops1_f32",""],["sub_vector_ops2_f32",""],["subtract_smaller_vector32",""],["subtract_vector32",""],["swap_halves32",""],["tan32",""],["tan_ops1_f32",""],["tan_ops2_f32",""],["tanh32",""],["tanh_ops1_f32",""],["tanh_ops2_f32",""],["to_complex32",""],["to_complex_ops1_f32",""],["to_complex_ops2_f32",""],["to_imag32",""],["to_imag_ops1_f32",""],["to_imag_ops2_f32",""],["to_real32",""],["to_real_ops1_f32",""],["to_real_ops2_f32",""],["unapply_custom_window32","See `apply_custom_window32` for a description of the `window` and `window_data` parameter."],["unapply_window32","See `apply_window32` for a description of the `window` parameter."],["unwrap32",""],["windowed_custom_fft32","See `apply_custom_window32` for a description of the `window` and `window_data` parameter."],["windowed_custom_ifft32","See `apply_custom_window32` for a description of the `window` and `window_data` parameter."],["windowed_custom_sfft32","See `apply_custom_window32` for a description of the `window` and `window_data` parameter."],["windowed_custom_sifft32","See `apply_custom_window32` for a description of the `window` and `window_data` parameter."],["windowed_fft32","See `apply_window32` for a description of the `window` parameter."],["windowed_ifft32","See `apply_window32` for a description of the `window` parameter."],["windowed_sfft32","See `apply_window32` for a description of the `window` parameter."],["windowed_sifft32","See `apply_window32` for a description of the `window` parameter."],["wrap32",""],["zero_interleave32",""],["zero_pad32","`padding_option` argument is translated to: Returns the vector domain as integer:"]],"type":[["PreparedOp1F32",""],["PreparedOp2F32",""]]});