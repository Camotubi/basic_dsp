initSidebarItems({"fn":[["abs64",""],["abs_ops1_f64",""],["abs_ops2_f64",""],["acos64",""],["acos_ops1_f64",""],["acos_ops2_f64",""],["acosh64",""],["acosh_ops1_f64",""],["acosh_ops2_f64",""],["add_complex_ops1_f64",""],["add_complex_ops2_f64",""],["add_points_ops1_f64",""],["add_points_ops2_f64",""],["add_real_ops1_f64",""],["add_real_ops2_f64",""],["add_smaller_vector64",""],["add_vector64",""],["add_vector_ops1_f64",""],["add_vector_ops2_f64",""],["apply_custom_window64","Creates a window from the function `window` and the void pointer `window_data`. The `window_data` pointer is passed to the `window` function at every call and can be used to store parameters."],["apply_window64","`window` argument is translated to:"],["asin64",""],["asin_ops1_f64",""],["asin_ops2_f64",""],["asinh64",""],["asinh_ops1_f64",""],["asinh_ops2_f64",""],["atan64",""],["atan_ops1_f64",""],["atan_ops2_f64",""],["atanh64",""],["atanh_ops1_f64",""],["atanh_ops2_f64",""],["clone64",""],["clone_from_ops1_f64",""],["clone_from_ops2_f64",""],["complex_conj_ops1_f64",""],["complex_conj_ops2_f64",""],["complex_data64",""],["complex_divide64",""],["complex_dot_product64",""],["complex_offset64",""],["complex_scale64",""],["complex_statistics64",""],["complex_statistics_splitted64",""],["conj64",""],["convolve64","`impulse_response` argument is translated to:"],["convolve_complex64","Convolves the vector with an impulse response defined by `impulse_response` and the void pointer `impulse_response_data`. The `impulse_response_data` pointer is passed to the `impulse_response` function at every call and can be used to store parameters."],["convolve_real64","Convolves the vector with an impulse response defined by `impulse_response` and the void pointer `impulse_response_data`. The `impulse_response_data` pointer is passed to the `impulse_response` function at every call and can be used to store parameters."],["convolve_vector64",""],["correlate64",""],["cos64",""],["cos_ops1_f64",""],["cos_ops2_f64",""],["cosh64",""],["cosh_ops1_f64",""],["cosh_ops2_f64",""],["cum_sum64",""],["decimatei64",""],["delete_ops1_f64",""],["delete_ops2_f64",""],["delete_vector64",""],["diff64",""],["diff_with_start64",""],["div_points_ops1_f64",""],["div_points_ops2_f64",""],["div_vector_ops1_f64",""],["div_vector_ops2_f64",""],["divide_smaller_vector64",""],["divide_vector64",""],["exec_prepared_ops1_f64",""],["exec_prepared_ops2_f64",""],["exp64",""],["exp_ops1_f64",""],["exp_ops2_f64",""],["expf64",""],["expf_ops1_f64",""],["expf_ops2_f64",""],["extend_prepared_ops1_f64","Prepares an operation. multi_ops1 will not be made available in for interop since the same functionality  can be created with prepared ops, and internally this is what this lib does too."],["fft64",""],["fft_shift64",""],["get_allocated_len64",""],["get_delta64",""],["get_domain64","Returns the vector domain as integer:"],["get_imag64",""],["get_len64",""],["get_mag_phase64",""],["get_magnitude64",""],["get_phase64",""],["get_points64",""],["get_real64",""],["get_real_imag64",""],["get_value64",""],["ifft64",""],["ifft_shift64",""],["interpolate_hermite64",""],["interpolate_lin64",""],["interpolatef64","`impulse_response` argument is translated to:"],["interpolatef_custom64","Convolves the vector with an impulse response defined by `impulse_response` and the void pointer `impulse_response_data`. The `impulse_response_data` pointer is passed to the `impulse_response` function at every call and can be used to store parameters."],["interpolatei64","`frequency_response` argument is translated to:"],["interpolatei_custom64","Convolves the vector with an impulse response defined by `frequency_response` and the void pointer `frequency_response_data`. The `frequency_response_data` pointer is passed to the `frequency_response` function at every call and can be used to store parameters."],["is_complex64",""],["ln64",""],["ln_ops1_f64",""],["ln_ops2_f64",""],["log64",""],["log_ops1_f64",""],["log_ops2_f64",""],["magnitude64",""],["magnitude_ops1_f64",""],["magnitude_ops2_f64",""],["magnitude_squared64",""],["magnitude_squared_ops1_f64",""],["magnitude_squared_ops2_f64",""],["map_aggregate_complex64","Warning: This function interface heavily works around the Rust type system and the safety it provides. Use with great care!"],["map_aggregate_real64","Warning: This function interface heavily works around the Rust type system and the safety it provides. Use with great care!"],["map_complex_ops1_f64",""],["map_complex_ops2_f64",""],["map_inplace_complex64",""],["map_inplace_real64",""],["map_real_ops1_f64",""],["map_real_ops2_f64",""],["merge64",""],["mirror64",""],["mul_points_ops1_f64",""],["mul_points_ops2_f64",""],["mul_vector_ops1_f64",""],["mul_vector_ops2_f64",""],["multiply_complex_exponential64",""],["multiply_complex_exponential_ops1_f64",""],["multiply_complex_exponential_ops2_f64",""],["multiply_complex_ops1_f64",""],["multiply_complex_ops2_f64",""],["multiply_frequency_response64","`frequency_response` argument is translated to:"],["multiply_frequency_response_complex64","Convolves the vector with an impulse response defined by `frequency_response` and the void pointer `frequency_response_data`. The `frequency_response` pointer is passed to the `frequency_response` function at every call and can be used to store parameters."],["multiply_frequency_response_real64","Convolves the vector with an impulse response defined by `frequency_response` and the void pointer `frequency_response_data`. The `frequency_response_data` pointer is passed to the `frequency_response` function at every call and can be used to store parameters."],["multiply_real_ops1_f64",""],["multiply_real_ops2_f64",""],["multiply_smaller_vector64",""],["multiply_vector64",""],["new64",""],["new_with_performance_options64",""],["override_data64",""],["phase64",""],["phase_ops1_f64",""],["phase_ops2_f64",""],["plain_fft64",""],["plain_ifft64",""],["plain_sfft64",""],["plain_sifft64",""],["powf64",""],["powf_ops1_f64",""],["powf_ops2_f64",""],["prepare_argument64",""],["prepare_argument_padded64",""],["prepared_ops1_f64","Prepares an operation. multi_ops1 will not be made available in for interop since the same functionality  can be created with prepared ops, and internally this is what this lib does too."],["prepared_ops2_f64","Prepares an operation. multi_ops2 will not be made available in for interop since the same functionality  can be created with prepared ops, and internally this is what this lib does too."],["real_dot_product64",""],["real_offset64",""],["real_scale64",""],["real_statistics64",""],["real_statistics_splitted64",""],["reverse64",""],["root64",""],["root_ops1_f64",""],["root_ops2_f64",""],["set_len64",""],["set_mag_phase64",""],["set_real_imag64",""],["set_value64",""],["sfft64",""],["sifft64",""],["sin64",""],["sin_ops1_f64",""],["sin_ops2_f64",""],["sinh64",""],["sinh_ops1_f64",""],["sinh_ops2_f64",""],["split_into64",""],["sqrt64",""],["sqrt_ops1_f64",""],["sqrt_ops2_f64",""],["square64",""],["square_ops1_f64",""],["square_ops2_f64",""],["sub_points_ops1_f64",""],["sub_points_ops2_f64",""],["sub_vector_ops1_f64",""],["sub_vector_ops2_f64",""],["subtract_smaller_vector64",""],["subtract_vector64",""],["swap_halves64",""],["tan64",""],["tan_ops1_f64",""],["tan_ops2_f64",""],["tanh64",""],["tanh_ops1_f64",""],["tanh_ops2_f64",""],["to_complex64",""],["to_complex_ops1_f64",""],["to_complex_ops2_f64",""],["to_imag64",""],["to_imag_ops1_f64",""],["to_imag_ops2_f64",""],["to_real64",""],["to_real_ops1_f64",""],["to_real_ops2_f64",""],["unapply_custom_window64","See `apply_custom_window64` for a description of the `window` and `window_data` parameter."],["unapply_window64","See `apply_window64` for a description of the `window` parameter."],["unwrap64",""],["windowed_custom_fft64","See `apply_custom_window64` for a description of the `window` and `window_data` parameter."],["windowed_custom_ifft64","See `apply_custom_window64` for a description of the `window` and `window_data` parameter."],["windowed_custom_sfft64","See `apply_custom_window64` for a description of the `window` and `window_data` parameter."],["windowed_custom_sifft64","See `apply_custom_window64` for a description of the `window` and `window_data` parameter."],["windowed_fft64","See `apply_window64` for a description of the `window` parameter."],["windowed_ifft64","See `apply_window64` for a description of the `window` parameter."],["windowed_sfft64","See `apply_window64` for a description of the `window` parameter."],["windowed_sifft64","See `apply_window64` for a description of the `window` parameter."],["wrap64",""],["zero_interleave64",""],["zero_pad64","`padding_option` argument is translated to: Returns the vector domain as integer:"]],"type":[["PreparedOp1F32",""],["PreparedOp2F32",""]]});